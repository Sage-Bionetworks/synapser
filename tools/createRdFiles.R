library(PythonEmbedInR)
library(rjson)

# This is factored out of autoGenerateRdFiles so it can be called during testing
initAutoGenerateRdFiles<-function(srcRootDir) {
	dictDocString<<-getDictDocString(srcRootDir)	
}

# create the autogenerated files
# srcRootDir is the root directory for the code base (i.e., prior to installation)
# the target dir is <srcRootDir>/man
autoGenerateRdFiles<-function(srcRootDir) {
	if (!file.exists(srcRootDir)) {
		stop(sprintf("%s does not exist.", srcRootDir))
	}
	initAutoGenerateRdFiles(srcRootDir)

	# get the Python documentation of all the functions
	functionInfo<-.getSynapseFunctionInfo(file.path(srcRootDir, "inst"))
	# get the Python documentation of all the classes
	classInfo<-.getSynapseClassInfo(file.path(srcRootDir, "inst"))
	# create a list for the constructors that's structured the same as the info for the functions
	constructorInfo<-lapply(X=classInfo, function(x){
				list(synName=x$name, 
						args=x$constructorArgs, 
						doc=x$doc, 
						title=sprintf("Constructor for objects of type %s", x$name),
						returned=sprintf("An object of type %s", x$name)
				)
			})
	# create doc's for all functions and constructors
	for (f in c(functionInfo,constructorInfo)) { 
		name<-f$synName
		args<-f$args
		doc<-f$doc
		title<-f$title
		if (is.null(f$returned)) {
			returned<-getReturned(doc)
		} else {
			returned = f$returned
		}
		tryCatch({
				content<-createFunctionRdContent(srcRootDir=srcRootDir,
						alias=name,
						title=title,
						description=doc,
						usage=usage(name, args),
						argument = formatArgsForArgumentSection(args, doc),
						returned=returned
				)
				# make sure all place holders were replaced
				p<-regexpr("##(title|description|usage|arguments|value|examples)##", content)[1]
				if (p>0) stop(sprintf("Failed to replace all placeholders in %s.Rd", name))
				writeContent(content, name, srcRootDir)
				}, 
				error=function(e){
					stop(sprintf("Error generating doc for %s: %s\n", name, e[[1]]))
				}
		)
	}

	for (c in classInfo) {
		tryCatch({
					content<-createClassRdContent(srcRootDir=srcRootDir,
							alias=paste0(c$name, "-class"),
							title=c$name,
							description=c$doc,
							methods=lapply(X=c$methods, function(x){list(name=x$name,description=x$doc,args=x$args)})
					)
				p<-regexpr("##(alias|title|description|methods)##", content)[1]
				if (p>0) stop(sprintf("Failed to replace all placeholders in %s.Rd", name))
				writeContent(content, paste0(c$name, "-class"), srcRootDir)
				}, 
				error=function(e){
					stop(sprintf("Error generating doc for %s: %s\n", name, e[[1]]))
				}
		)
	}
}

# create the 'usage' section of the doc
# this is also used to document the 'methods' of a class
usage<-function(name, args) {
	result<-NULL
	argNames<-args$args
	keywords<-args$keywords
	varargs<-args$varargs
	defaults<-args$defaults
	result<-NULL
	if (length(argNames)>0) {
		# self can be the first arg of a method or function, typ can be the first arg of a constructor
		if (argNames[1]!='self' && argNames[1]!='typ') argStart<-1 else argStart<-2
		if (argStart<=length(argNames)) {
			for (i in argStart:length(argNames)) {
				argName<-argNames[i]
				defaultIndex<- i+length(defaults)-length(argNames)
				if (defaultIndex>0) {
					result<-append(result, sprintf("%s=%s", argName, defaults[defaultIndex]))
				} else {
					result<-append(result, argName)
				}
			}
		}
	}
	if (!is.null(keywords) || !is.null(varargs)) result<-append(result, "...")
	sprintf("%s(%s)", name, paste(result, collapse=", "))
}

# create a named list of arguments and their descriptions
# suitable for use in the arguments section
formatArgsForArgumentSection<-function(args, details) {
	argNames<-args$args
	result<-NULL
	argDescriptions<-parseArgDescriptionsFromDetails(details)
	if (length(argNames)>0) {
		if (argNames[1]!='self' && argNames[1]!='typ') argStart<-1 else argStart<-2
		if (argStart<=length(argNames)) {
			for (i in argStart:length(argNames)) {
				argName<-argNames[[i]]
				argDescription<-argDescriptions[[argName]]
				if (is.null(argDescription)) argDescription<-""
				# now do any conversion of the description
				argDescription<-pyVerbiageToLatex(argDescription)
				argDescription<-insertLatexNewLines(argDescription)
				result<-append(result, sprintf("\\item{%s}{%s}", argName, argDescription))
			}
		}
	}
	paste(result, collapse="\n")
}


getDictDocString<-function(srcRootDir) {
	file<-sprintf("%s/tools/dictDocString.txt", srcRootDir)
	connection<-file(file, open="r")
	result<-paste(readLines(connection), collapse="\n")
	close(connection)
	result
}

# any conversion of Sphinx text to Latex text goes here
convertSphinxToLatex<-function(raw) {
	changeSphinxHyperlinksToLatex(raw)
}

changeSphinxHyperlinksToLatex<-function(raw) {
	gsub("`([^<\n]*) <([^>\n]*)>`_", "\\\\href{\\2}{\\1}", raw)
}

insertLatexNewLines<-function(raw) {
	gsub("\n", "\\cr\n", raw, fixed=TRUE)
}

parseArgDescriptionsFromDetails<-function(raw) {
	# escape any escaped-escapes
	preprocessed<-gsub("\\\\", "\\\\\\\\", raw)
	# change all quotes to escaped quotes
	preprocessed<-gsub("\"", "\\\\\"", preprocessed)
	# change \r\n to \n
	preprocessed<-gsub("\r\n", "\n", preprocessed)

	# find parameters and convert them, along with their def'ns, to json
	# reminder: \w in a regexp means "word character", [A-Za-z0-9_]
	json<-gsub(":(parameter|param|type|var) (\\w+):", "\",\"\\2\":\"", preprocessed)
	# prepend "{\"unusedPrefix\":\""
	# add "\"}" to the end
	json<-paste0("{\"unusedPrefix\":\"", json, "\"}")
	# parse JSON into named list
	paramsList<-fromJSON(json)
	# truncate each entry at end
	result<-lapply(X=paramsList, 
		function(x) {
			p<-regexpr("\n\n|\n:returns?:|\n[Ee]xample:", x)[1]
			if(p<0)return(x)
			substr(x,1,p-1)
		}
	)
	result$unusedPrefix<-NULL
	result
}

pyVerbiageToLatex<-function(raw) {
	if (missing(raw) || is.null(raw) || length(raw)==0 || nchar(raw)==0) return("")
	# this replaces ':param <param name>:' with '\nparam name:'
	# same for parameter, type, var
	result<-raw
	result<-gsub(":(parameter|param|type|var) (\\w+):", "\n\\2:", result)
	# Reminder:  \\S means 'not whitespace'
	result<-gsub(":py:class:`(\\S+\\.)*(\\S+)`", "\\2", result)
	
	convertToUpper<-"##convertToUpper##" # marks character to convert
	result<-gsub(":py:mod:`(\\S+\\.)*(\\S+)`", paste0(convertToUpper,"\\2"), result)
	result<-gsub(":py:(func|meth):`Synapse.(\\w+)`", paste0("syn", convertToUpper,"\\2"), result)
	result<-gsub(":py:(func|meth):`synapseclient.Synapse.(\\w+)`", paste0("syn",convertToUpper,"\\2"), result)
	# anything else we simply leave in place for manual curation:
	result<-gsub(":py:(func|meth):`([^`]*)`", "\\2", result)
	
	while (TRUE) {
		ctuIndex<-regexpr(convertToUpper, result)[[1]]
		if (ctuIndex<0) break
		lcChar<-nchar(convertToUpper)+ctuIndex
		result<-paste0(substring(result,1,ctuIndex-1), 
				toupper(substring(result,lcChar,lcChar)), 
				substring(result, lcChar+1))
	}

	result<-gsub(dictDocString, "\nConstructor accepts named arguments.\n", result, fixed=TRUE)

	result<-convertSphinxToLatex(result)
}

getDescription<-function(raw) {
	if (missing(raw) || is.null(raw) || length(raw)==0 || nchar(raw)==0) return("")
	preprocessed<-gsub("\r\n", "\n", raw, fixed=TRUE)
	# sometimes the text is a one-line description
	if (!grepl("\n", preprocessed)) return(preprocessed)
	# find everything up to the first double-newline
	# TODO consider removing the \n\n terminator and return everything up to a param, return or example token
	terminatorIndex<-regexpr("\n\n|\n?:(parameter|param|type|var)|\n?:returns?:|\n[Ee]xample:", preprocessed)[1]
	if (terminatorIndex<=1) return("")
	substr(preprocessed, 1, terminatorIndex-1)
}

getReturned<-function(raw) {
	if (missing(raw) || is.null(raw) || length(raw)==0 || nchar(raw)==0) return("")
	preprocessed<-gsub("\r\n", "\n", raw, fixed=TRUE)
	if (!grepl(":returns?:", preprocessed)) return("")
	# get whatever follows :return: or :returns:
	result<-gsub(".*:returns?:(.*)", "\\1", preprocessed)
	# check for any trailing content
	doubleNewLineIndex<-regexpr("\n\n", result)[1]
	if (doubleNewLineIndex<=1) return(result)
	substr(result, 1, doubleNewLineIndex-1)
}

getExample<-function(raw) {
	if (missing(raw) || is.null(raw) || length(raw)==0 || nchar(raw)==0) return("")
	preprocessed<-gsub("\r\n", "\n", raw, fixed=TRUE)
	pattern<-".*[Ee]xample::?\n\n(.*)"
	if (!grepl(pattern, preprocessed)) return("")
	result<-gsub(pattern, "\\1", preprocessed)
	# check for any trailing content
	doubleNewLineIndex<-regexpr("\n\n", result)[1]
	if (doubleNewLineIndex<=1) return(result)
	substr(result, 1, doubleNewLineIndex-1)
}

createFunctionRdContent<-function(srcRootDir, alias, title, description, usage, argument, returned) {
	templateFile<-sprintf("%s/tools/rdFunctionTemplate.Rd", srcRootDir)
	connection<-file(templateFile, open="r")
	template<-paste(readLines(connection), collapse="\n")
	close(connection)
	
	content<-template
	content<-gsub("##alias##", alias, content, fixed=TRUE)
	if (!missing(title) && !is.null(title)) content<-gsub("##title##", title, content, fixed=TRUE)
	examples<-NULL
	if (!missing(description) && !is.null(description)) {
		processedDescription<-pyVerbiageToLatex(getDescription(description))
		content<-gsub("##description##", processedDescription, content, fixed=TRUE)
		examples<-pyVerbiageToLatex(getExample(description))
	} else {
		content<-gsub("##description##", "", content, fixed=TRUE)
	}
	if (!missing(returned) && !is.null(returned)) {
		value<-pyVerbiageToLatex(returned)
		content<-gsub("##value##", value, content, fixed=TRUE)
	} else {
		content<-gsub("##value##", "", content, fixed=TRUE)
	}
	if (!missing(usage) && !is.null(usage)) content<-gsub("##usage##", usage, content, fixed=TRUE)
	if (!missing(argument) && !is.null(argument)) content<-gsub("##arguments##", argument, content, fixed=TRUE)
	if (is.null(examples)) {
		content<-gsub("##examples##", "", content, fixed=TRUE)
	} else {
		# we comment out the examples which come from the Python client and need to be curated
		content<-gsub("##examples##", paste0("%\\dontrun{\n%", gsub("\n", "\n%", examples), "\n%}"), content, fixed=TRUE)
	}
	content
}

createMethodContent<-function(f) {
	paste0("\\item \\code{", usage(f$name, f$args), "}: ", f$description)
}

createClassRdContent<-function(srcRootDir, alias, title, description, methods) {
	templateFile<-sprintf("%s/tools/rdClassTemplate.Rd", srcRootDir)
	connection<-file(templateFile, open="r")
	template<-paste(readLines(connection), collapse="\n")
	close(connection)
	
	content<-template
	content<-gsub("##alias##", alias, content, fixed=TRUE)
	if (!missing(title) && !is.null(title)) content<-gsub("##title##", title, content, fixed=TRUE)
	if (!missing(description) && !is.null(description)) {	
		processedDescription<-pyVerbiageToLatex(getDescription(description))
		content<-gsub("##description##", processedDescription, content, fixed=TRUE)
	}
	methodContent<-NULL
	for (method in methods) {
		methodDescription<-method$description
		if (method$name==title) {
			method$description<-sprintf("Constructor for \\code{\\link{%s}}", title)
		} else {
			if (!is.null(methodDescription)) {
				methodDescription<-pyVerbiageToLatex(getDescription(methodDescription))
				methodDescription<-insertLatexNewLines(methodDescription)
				method$description<-methodDescription
			}
		}
		methodContent<-c(methodContent, createMethodContent(method))
	}
	content<-gsub("##methods##", paste(methodContent, collapse="\n"), content, fixed=TRUE)
	content
}


writeContent<-function(content, className, srcRootDir) {
	fileName<-sprintf("%s/man/%s.Rd", srcRootDir, className)
	connection<-file(fileName, open="w")
	writeChar(content, connection, eos=NULL)
	writeChar("\n", connection, eos=NULL)
	close(connection)
}
