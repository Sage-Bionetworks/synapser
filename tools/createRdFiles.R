library(PythonEmbedInR)
library(rjson)

# This is factored out of autoGenerateRdFiles so it can be called during testing
initAutoGenerateRdFiles<-function(srcRootDir) {
	dictDocString<<-getDictDocString(srcRootDir)	
}

# create the autogenerated files
# srcRootDir is the root directory for the code base (i.e., prior to installation)
# the target dir is <srcRootDir>/auto-man
autoGenerateRdFiles<-function(srcRootDir) {
	if (!file.exists(srcRootDir)) {
		stop(sprintf("%s does not exist.", srcRootDir))
	}
	initAutoGenerateRdFiles(srcRootDir)

	# get the Python documentation of all the functions
	functionInfo<-.getSynapseFunctionInfo(file.path(srcRootDir, "inst"))
	# get the Python documentation of all the classes
	classInfo<-.getSynapseClassInfo(file.path(srcRootDir, "inst"))
	# create a list for the constructors that's structured the same as the info for the functions
	constructorInfo<-lapply(X=classInfo, function(x){
				list(synName=x$name, 
						args=x$constructorArgs, 
						doc=x$doc, 
						title=sprintf("Constructor for objects of type %s", x$name),
						returned=sprintf("An object of type %s", x$name)
				)
			})
	# create doc's for all functions and constructors
	for (f in c(functionInfo,constructorInfo)) { 
		name<-f$synName
		args<-f$args
		doc<-f$doc
		title<-f$title
		if (is.null(f$returned)) {
			returned<-getReturned(doc)
		} else {
			returned = f$returned
		}
		tryCatch({
				argDescriptionsFromDoc<-parseArgDescriptionsFromDetails(doc)
				argNames<-args$args
				formatArgsResult<-formatArgsForArgumentSection(argNames, argDescriptionsFromDoc)
				content<-createFunctionRdContent(srcRootDir=srcRootDir,
						alias=name,
						title=title,
						description=doc,
						usage=usage(name, args, argDescriptionsFromDoc),
						argument = formatArgsResult,
						returned=returned
				)
				# make sure all place holders were replaced
				p<-regexpr("##(title|description|usage|arguments|value|examples)##", content)[1]
				if (p>0) stop(sprintf("Failed to replace all placeholders in %s.Rd", name))
				writeContent(content, name, srcRootDir)
				}, 
				error=function(e){
					stop(sprintf("Error generating doc for %s: %s\n", name, e[[1]]))
				}
		)
	}

	for (c in classInfo) {
		tryCatch({
					content<-createClassRdContent(srcRootDir=srcRootDir,
							alias=paste0(c$name, "-class"),
							title=c$name,
							description=c$doc,
							methods=lapply(X=c$methods, function(x){
								argDescriptionsFromDoc<-parseArgDescriptionsFromDetails(x$doc)
								list(name=x$name,description=x$doc,args=x$args, argDescriptionsFromDoc=argDescriptionsFromDoc)
							})
					)
				p<-regexpr("##(alias|title|description|methods)##", content)[1]
				if (p>0) stop(sprintf("Failed to replace all placeholders in %s.Rd", name))
				writeContent(content, paste0(c$name, "-class"), srcRootDir)
				}, 
				error=function(e){
					stop(sprintf("Error generating doc for %s: %s\n", name, e[[1]]))
				}
		)
	}
}

# create the 'usage' section of the doc
# this is also used to document the 'methods' of a class
usage<-function(name, args, argDescriptionsFromDoc) {
	result<-NULL
	argNames<-args$args
	defaults<-args$defaults
	result<-NULL
	if (length(argNames)>0) {
		# self can be the first arg of a method or function, typ can be the first arg of a constructor
		if (argNames[1]!='self' && argNames[1]!='typ') argStart<-1 else argStart<-2
		if (argStart<=length(argNames)) {
			for (i in argStart:length(argNames)) {
				argName<-argNames[[i]]
				defaultIndex<- i+length(defaults)-length(argNames)
				if (defaultIndex>0) {
					result<-append(result, sprintf("%s=%s", argName, defaults[defaultIndex]))
				} else {
					result<-append(result, argName)
				}
				# remove it from the list of arguments mentioned in the docstring
				argDescriptionsFromDoc[[argName]]<-NULL
			}
		}
	}
	# are there any remaining arguments, not included in the argument list?
	# if so, they are kwargs / named parameters
	if (length(names(argDescriptionsFromDoc))>0) {
		result<-append(result, lapply(names(argDescriptionsFromDoc), 
			function(x) {sprintf("%s=NULL", x)}))
	}
	sprintf("%s(%s)", name, paste(result, collapse=", "))
}

# create a named list of arguments and their descriptions
# suitable for use in the arguments section
# argNames is the list of explicit arguments from inspecting the function
# argDescriptionsFromDoc is the result of parsing the docstring, looking for parameters
formatArgsForArgumentSection<-function(argNames, argDescriptionsFromDoc) {
	result<-NULL
	if (length(argNames)>0) {
		if (argNames[1]!='self' && argNames[1]!='typ') argStart<-1 else argStart<-2
		if (argStart<=length(argNames)) {
			for (i in argStart:length(argNames)) {
				argName<-argNames[[i]]
				argDescription<-argDescriptionsFromDoc[[argName]]
				# remove it from the list of arguments mentioned in the docstring
				argDescriptionsFromDoc[[argName]]<-NULL
				if (is.null(argDescription)) argDescription<-""
				result<-append(result, sprintf("\\item{%s}{%s}", argName, argDescription))
			}
		}
	}
	# are there any remaining arguments, not included in the argument list?
	# if so, they are kwargs / named parameters
	if (length(argDescriptionsFromDoc)>0) {
		result<-append(result, lapply(names(argDescriptionsFromDoc), 
			function(x) {
				sprintf("\\item{%s}{optional named parameter: %s}", x, argDescriptionsFromDoc[[x]])
			}))
	}
	paste(result, collapse="\n")
}


getDictDocString<-function(srcRootDir) {
	file<-sprintf("%s/tools/dictDocString.txt", srcRootDir)
	connection<-file(file, open="r")
	result<-paste(readLines(connection), collapse="\n")
	close(connection)
	result
}

# any conversion of Sphinx text to Latex text goes here
convertSphinxToLatex<-function(raw) {
	changeSphinxHyperlinksToLatex(raw)
}

changeSphinxHyperlinksToLatex<-function(raw) {
	gsub("`([^<\n]*) <([^>\n]*)>`_", "\\\\href{\\2}{\\1}", raw)
}

insertLatexNewLines<-function(raw) {
	gsub("\n", "\\cr\n", raw, fixed=TRUE)
}

# returns a named list in which the names are arguments
# and the values are their descriptions
parseArgDescriptionsFromDetails<-function(raw) {
	# escape any escaped-escapes
	preprocessed<-gsub("\\\\", "\\\\\\\\", raw)
	# change all quotes to escaped quotes
	preprocessed<-gsub("\"", "\\\\\"", preprocessed)
	# change \r\n to \n
	preprocessed<-gsub("\r\n", "\n", preprocessed)

	# find parameters and convert them, along with their def'ns, to json
	# reminder: \w in a regexp means "word character", [A-Za-z0-9_]
	json<-gsub(":(parameter|param|var) (\\w+):", "\",\"\\2\":\"", preprocessed)
	# prepend "{\"unusedPrefix\":\""
	# add "\"}" to the end
	json<-paste0("{\"unusedPrefix\":\"", json, "\"}")
	# parse JSON into named list
	paramsList<-fromJSON(json)
	# truncate each entry at end
	result<-lapply(X=paramsList, 
		function(x) {
			p<-regexpr("\n\n|\n:returns?:|\n[Ee]xample:", x)[1]
			if(p<0) {
				result<-x
			} else {
				result<-substr(x,1,p-1)
			}
			# now do any conversion of the description
			result<-pyVerbiageToLatex(result)
			result<-insertLatexNewLines(result)
			result
		}
	)
	result$unusedPrefix<-NULL
	if (length(names(result))!=length(unique(names(result)))) {
		message(sprintf("Warning:  encountered repeated function arguments definitions in docstring: %s", raw))
	}
	result
}

pyVerbiageToLatex<-function(raw) {
	if (missing(raw) || is.null(raw) || length(raw)==0 || nchar(raw)==0) return("")
	# this replaces ':param <param name>:' with '\nparam name:'
	# same for parameter, type, var
	result<-raw
	result<-gsub(":(parameter|param|var) (\\w+):", "\n\\2:", result)
	# Reminder:  \\S means 'not whitespace'
	result<-gsub(":py:class:`(\\S+\\.)*(\\S+)`", "\\2", result)
	
	convertToUpper<-"##convertToUpper##" # marks character to convert
	result<-gsub(":py:mod:`(\\S+\\.)*(\\S+)`", paste0(convertToUpper,"\\2"), result)
	result<-gsub(":py:(func|meth):`Synapse.(\\w+)`", paste0("syn", convertToUpper,"\\2"), result)
	result<-gsub(":py:(func|meth):`synapseclient.Synapse.(\\w+)`", paste0("syn",convertToUpper,"\\2"), result)
	# anything else we simply leave in place for manual curation:
	result<-gsub(":py:(func|meth):`([^`]*)`", "\\2", result)
	
	while (TRUE) {
		ctuIndex<-regexpr(convertToUpper, result)[[1]]
		if (ctuIndex<0) break
		lcChar<-nchar(convertToUpper)+ctuIndex
		result<-paste0(substring(result,1,ctuIndex-1), 
				toupper(substring(result,lcChar,lcChar)), 
				substring(result, lcChar+1))
	}

	result<-gsub(dictDocString, "\nConstructor accepts named arguments.\n", result, fixed=TRUE)

	result<-convertSphinxToLatex(result)
}

getDescription<-function(raw) {
	if (missing(raw) || is.null(raw) || length(raw)==0 || nchar(raw)==0) return("")
	preprocessed<-gsub("\r\n", "\n", raw, fixed=TRUE)
	# find everything up to the first syphinx token following the description
	terminatorIndex<-regexpr("\n*:(parameter|param|type|var)|\n*?:returns?:|\n{1,}[Ee]xample:", preprocessed)[1]
	if (terminatorIndex<1) return(preprocessed)
	substr(preprocessed, 1, terminatorIndex-1)
}

getReturned<-function(raw) {
	if (missing(raw) || is.null(raw) || length(raw)==0 || nchar(raw)==0) return("")
	preprocessed<-gsub("\r\n", "\n", raw, fixed=TRUE)
	if (!grepl(":returns?:", preprocessed)) return("")
	# get whatever follows :return: or :returns:
	result<-gsub(".*:returns?:(.*)", "\\1", preprocessed)
	# check for any trailing content
	doubleNewLineIndex<-regexpr("\n\n", result)[1]
	if (doubleNewLineIndex<=1) return(result)
	substr(result, 1, doubleNewLineIndex-1)
}

getExample<-function(raw) {
	if (missing(raw) || is.null(raw) || length(raw)==0 || nchar(raw)==0) return("")
	preprocessed<-gsub("\r\n", "\n", raw, fixed=TRUE)
	pattern<-".*[Ee]xample::?\n\n(.*)"
	if (!grepl(pattern, preprocessed)) return("")
	result<-gsub(pattern, "\\1", preprocessed)
	# check for any trailing content
	doubleNewLineIndex<-regexpr("\n\n", result)[1]
	if (doubleNewLineIndex<=1) return(result)
	substr(result, 1, doubleNewLineIndex-1)
}

createFunctionRdContent<-function(srcRootDir, alias, title, description, usage, argument, returned) {
	templateFile<-sprintf("%s/tools/rdFunctionTemplate.Rd", srcRootDir)
	connection<-file(templateFile, open="r")
	template<-paste(readLines(connection), collapse="\n")
	close(connection)
	
	content<-template
	content<-gsub("##alias##", alias, content, fixed=TRUE)
	if (!missing(title) && !is.null(title)) content<-gsub("##title##", title, content, fixed=TRUE)
	examples<-NULL
	if (!missing(description) && !is.null(description)) {
		processedDescription<-pyVerbiageToLatex(getDescription(description))
		content<-gsub("##description##", processedDescription, content, fixed=TRUE)
		examples<-pyVerbiageToLatex(getExample(description))
	} else {
		content<-gsub("##description##", "", content, fixed=TRUE)
	}
	if (!missing(returned) && !is.null(returned)) {
		value<-pyVerbiageToLatex(returned)
		content<-gsub("##value##", value, content, fixed=TRUE)
	} else {
		content<-gsub("##value##", "", content, fixed=TRUE)
	}
	if (!missing(usage) && !is.null(usage)) content<-gsub("##usage##", usage, content, fixed=TRUE)
	if (!missing(argument) && !is.null(argument)) content<-gsub("##arguments##", argument, content, fixed=TRUE)
	if (is.null(examples)) {
		content<-gsub("##examples##", "", content, fixed=TRUE)
	} else {
		# we comment out the examples which come from the Python client and need to be curated
		content<-gsub("##examples##", paste0("%\\dontrun{\n%", gsub("\n", "\n%", examples), "\n%}"), content, fixed=TRUE)
	}
	content
}

createMethodContent<-function(f) {
	paste0("\\item \\code{", usage(f$name, f$args, f$argDescriptionsFromDoc), "}: ", f$description)
}

createClassRdContent<-function(srcRootDir, alias, title, description, methods) {
	templateFile<-sprintf("%s/tools/rdClassTemplate.Rd", srcRootDir)
	connection<-file(templateFile, open="r")
	template<-paste(readLines(connection), collapse="\n")
	close(connection)
	
	content<-template
	content<-gsub("##alias##", alias, content, fixed=TRUE)
	if (!missing(title) && !is.null(title)) content<-gsub("##title##", title, content, fixed=TRUE)
	if (!missing(description) && !is.null(description)) {	
		processedDescription<-pyVerbiageToLatex(getDescription(description))
		content<-gsub("##description##", processedDescription, content, fixed=TRUE)
	}
	methodContent<-NULL
	for (method in methods) {
		methodDescription<-method$description
		if (method$name==title) {
			method$description<-sprintf("Constructor for \\code{\\link{%s}}", title)
		} else {
			if (!is.null(methodDescription)) {
				methodDescription<-pyVerbiageToLatex(getDescription(methodDescription))
				methodDescription<-insertLatexNewLines(methodDescription)
				method$description<-methodDescription
			}
		}
		methodContent<-c(methodContent, createMethodContent(method))
	}
	content<-gsub("##methods##", paste(methodContent, collapse="\n"), content, fixed=TRUE)
	content
}


writeContent<-function(content, className, srcRootDir) {
	targetFolder<-file.path(srcRootDir, "auto-man")
	if (!file.exists(targetFolder)) {
		dir.create(targetFolder)
	}
	filePath<-file.path(targetFolder, sprintf("%s.Rd", className))
	connection<-file(filePath, open="w")
	writeChar(content, connection, eos=NULL)
	writeChar("\n", connection, eos=NULL)
	close(connection)
}
